use std::collections::HashMap;
use std::collections::VecDeque;

use crate::header::CTStackVal;
use crate::header::CTStackVal::*;
use crate::header::Capability;
use crate::header::Capability::*;
use crate::header::Error;
use crate::header::Error::*;
use crate::header::Id;
use crate::header::Kind::*;
use crate::header::KindContext;
use crate::header::KindContextEntry::*;
use crate::header::Label;
use crate::header::Pos;
use crate::header::Region;
use crate::header::Region::*;
use crate::header::Type;
use crate::header::Type::*;
use crate::header::UnverifiedOpcode;
use crate::header::UnverifiedOpcode::*;
use crate::header::UnverifiedStmt;
use crate::header::VerifiedOpcode;
use crate::header::VerifiedStmt;

pub fn go(stmts: Vec<UnverifiedStmt>) -> Result<Vec<VerifiedStmt>, Error> {
    let mut out: Vec<VerifiedStmt> = vec![];
    let stmts2: Vec<(VerifiedStmt, Constraints)> = stmts
        .iter()
        .map(|stmt| pass(stmt))
        .collect::<Result<Vec<_>, Error>>()?;
    let mut constraints: Constraints = HashMap::new();
    for pair in stmts2 {
        // TODO: check that the expected types of global functions are their actual types
        let (stmt, c) = pair;
        constraints.extend(c);
        out.push(stmt);
    }
    return Ok(out);
}

/// The type of the stack; a sequence of the types of things on the stack.
type StackType = VecDeque<Type>;
/// The type of the compile-time stack, a stack of compile-time values.
type CTStackType = Vec<CTStackVal>;
/// The type of the constraints produced by the first pass of the verifier.
/// Note that this is not like Hindley-Milner or anything like that:
/// the first pass gets the types of all the functions without using any constraints.
/// The constraints are only checked to make sure the functions are well-typed, not to derive any types.
type Constraints = HashMap<Label, (StackType, CTStackType)>;

/// The first pass of the verifier.
fn pass(
    func: &UnverifiedStmt,
) -> Result<(VerifiedStmt, HashMap<Label, (StackType, CTStackType)>), Error> {
    let UnverifiedStmt::Func(label, ops) = func;
    let mut ops_iter = ops.iter();

    // The stacks used for this pass algorithm.
    let mut compile_time_stack: CTStackType = vec![];
    let mut stack_type: StackType = VecDeque::from([]);
    let mut exist_stack: Vec<Id> = vec![];

    // The types the function expects the top of the stack to have.
    let mut arg_types: Vec<Type> = vec![];
    // The capabilities the function expects the caller to have.
    let mut cap_coeffect: Vec<Capability> = vec![];

    // The constraints generated by this first pass.
    let mut constraints = HashMap::new();
    // The verified bytecode produced by this first pass.
    let mut verified_ops: Vec<VerifiedOpcode> = vec![];

    // The list of region variables the function is quantified (polymorphic) over.
    let mut rgn_vars: Vec<Id> = vec![];
    // The list of capability variables the function is quantified (polymorphic) over, and their bounds.
    let mut capability_bounds: HashMap<Id, Vec<Capability>> = HashMap::new();
    // The list of type variables the function is quantified (polymorphic) over.
    let mut type_vars: Vec<Id> = vec![];

    // The kind context (\Delta in the Capability Calculus paper) the function has.
    // This is generated alongside the above three variables, capturing the same information in a different form
    // that's useful for different purposes.
    let mut kind_context: KindContext = vec![];

    // The generator of fresh identifiers.
    let mut fresh_id: u32 = 0;
    // The variable tracking the current byte position, for nice error reporting.
    let mut pos = *label;

    loop {
        match ops_iter.next() {
            None => break,
            Some(op) => match op {
                ReqOp => match compile_time_stack.pop() {
                    None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    Some(TypeCTStackVal(t)) => {
                        arg_types.push(t.clone());
                        stack_type.push_front(t);
                    }
                    Some(CapCTStackVal(caps)) => cap_coeffect.extend(caps),
                    Some(ctval) => {
                        return Err(KindErrorReq(pos, ctval));
                    }
                },
                RegionOp => {
                    let id = Id(*label, fresh_id);
                    let r = VarRgn(id);
                    compile_time_stack.push(RegionCTStackVal(r));
                    rgn_vars.push(id);
                    kind_context.push(RegionKindContextEntry(id));
                    fresh_id += 1;
                }
                HeapOp => compile_time_stack.push(RegionCTStackVal(Region::HeapRgn)),
                CapOp => {
                    let id = Id(*label, fresh_id);
                    let var = VarCap(id);
                    let cap = vec![var];
                    capability_bounds.insert(id, vec![]);
                    kind_context.push(CapabilityKindContextEntry(id, vec![]));
                    compile_time_stack.push(CapCTStackVal(cap));
                    fresh_id += 1;
                }
                CapLEOp => {
                    let mb_bound = compile_time_stack.pop();
                    match mb_bound {
                        Some(CapCTStackVal(bound)) => {
                            let id = Id(*label, fresh_id);
                            let var = VarCap(id);
                            compile_time_stack.push(CapCTStackVal(vec![var]));
                            capability_bounds.insert(id, bound.clone());
                            kind_context.push(CapabilityKindContextEntry(id, bound));
                            fresh_id += 1;
                        }
                        Some(ctval) => return Err(KindError(pos, *op, CapabilityKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                UniqueOp => {
                    let mb_rgn = compile_time_stack.pop();
                    match mb_rgn {
                        Some(RegionCTStackVal(r)) => {
                            compile_time_stack.push(CapCTStackVal(vec![UniqueCap(r)]))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, RegionKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                RWOp => {
                    let mb_rgn = compile_time_stack.pop();
                    match mb_rgn {
                        Some(RegionCTStackVal(r)) => {
                            compile_time_stack.push(CapCTStackVal(vec![ReadWriteCap(r)]))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, RegionKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                BothOp => {
                    let mb_cap1 = compile_time_stack.pop();
                    match mb_cap1 {
                        Some(CapCTStackVal(cap1)) => {
                            let mb_cap2 = compile_time_stack.pop();
                            match mb_cap2 {
                                Some(CapCTStackVal(cap2)) => compile_time_stack
                                    .push(CapCTStackVal([&cap1[..], &cap2[..]].concat())),
                                Some(ctval) => {
                                    return Err(KindError(pos, *op, CapabilityKind, ctval))
                                }
                                None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                            }
                        }
                        Some(ctval) => return Err(KindError(pos, *op, CapabilityKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                HandleOp => {
                    let mb_rgn = compile_time_stack.pop();
                    match mb_rgn {
                        Some(RegionCTStackVal(r)) => {
                            compile_time_stack.push(TypeCTStackVal(HandleType(r)))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, RegionKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                I32Op => compile_time_stack.push(TypeCTStackVal(I32Type)),
                EndFunctionOp => panic!("op-end found during verification"),
                MutOp => {
                    let mb_type = compile_time_stack.pop();
                    match mb_type {
                        Some(TypeCTStackVal(t)) => {
                            compile_time_stack.push(TypeCTStackVal(MutableType(Box::new(t))))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                TupleOp(size) => {
                    let mut component_types = vec![];
                    for _ in 0..*size {
                        let mb_type = compile_time_stack.pop();
                        match mb_type {
                            Some(TypeCTStackVal(t)) => component_types.push(t),
                            Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                            None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                        }
                    }
                    let mb_rgn = compile_time_stack.pop();
                    match mb_rgn {
                        Some(RegionCTStackVal(r)) => {
                            compile_time_stack.push(TypeCTStackVal(TupleType(component_types, r)))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, RegionKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                ArrOp => {
                    let mb_type = compile_time_stack.pop();
                    match mb_type {
                        Some(TypeCTStackVal(t)) => {
                            compile_time_stack.push(TypeCTStackVal(ArrayType(Box::new(t))))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                AllOp => {
                    let id = Id(*label, fresh_id);
                    let t = VarType(id);
                    compile_time_stack.push(TypeCTStackVal(t));
                    type_vars.push(id);
                    kind_context.push(TypeKindContextEntry(id));
                    fresh_id += 1
                }
                SomeOp => {
                    let id = Id(*label, fresh_id);
                    compile_time_stack.push(TypeCTStackVal(VarType(id)));
                    exist_stack.push(id);
                    fresh_id += 1;
                }
                EmosOp => {
                    let mb_var = exist_stack.pop();
                    match mb_var {
                        None => return Err(TypeErrorEmptyExistStack(pos, *op)),
                        Some(id) => {
                            let mb_type = compile_time_stack.pop();
                            match mb_type {
                                Some(TypeCTStackVal(t)) => compile_time_stack
                                    .push(TypeCTStackVal(ExistsType(id, Box::new(t)))),
                                Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                                None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                            }
                        }
                    }
                }
                FuncOp(num_args) => {
                    let mut arg_ts = vec![];
                    for _ in 0..*num_args {
                        let mb_type = compile_time_stack.pop();
                        match mb_type {
                            Some(TypeCTStackVal(t)) => arg_ts.push(t),
                            Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                            None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                        }
                    }
                    let mb_cap = compile_time_stack.pop();
                    match mb_cap {
                        Some(CapCTStackVal(c)) => {
                            compile_time_stack.push(TypeCTStackVal(FuncType(vec![], c, arg_ts)))
                        }
                        Some(ctval) => return Err(KindError(pos, *op, CapabilityKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    }
                }
                CTGetOp(i) => {
                    let ct_stack_len = compile_time_stack.len();
                    if ct_stack_len == 0 {
                        return Err(TypeErrorEmptyCTStack(pos, *op));
                    }
                    let i2 = usize::from(*i);
                    if ct_stack_len - 1 < i2 {
                        return Err(TypeErrorParamOutOfRange(pos, *op));
                    }
                    compile_time_stack.push(
                        compile_time_stack
                            .get(ct_stack_len - i2 - 1)
                            .unwrap()
                            .clone(),
                    );
                }
                CTPopOp => {
                    compile_time_stack.pop();
                }
                UnpackOp => {
                    let mb_existential = stack_type.pop_back();
                    match mb_existential {
                        Some(t) => match t {
                            ExistsType(_id, t) => {
                                stack_type.push_back(*t) // simply remove the quantifier, unbinding its variable
                            }
                            _ => return Err(TypeErrorExistentialExpected(pos, t)),
                        },
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                }
                UnverifiedOpcode::GetOp(i) => {
                    let stack_len = stack_type.len();
                    if stack_len == 0 {
                        return Err(TypeErrorEmptyStack(pos, *op));
                    }
                    let i2 = usize::from(*i);
                    if stack_len - 1 < i2 {
                        return Err(TypeErrorParamOutOfRange(pos, *op));
                    }
                    stack_type.push_back(stack_type.get(stack_len - 1 - i2).unwrap().clone());
                    verified_ops.push(VerifiedOpcode::GetOp(*i))
                }
                UnverifiedOpcode::InitOp(i) => {
                    let mb_val = stack_type.pop_back();
                    let mb_tpl = stack_type.pop_back();
                    match mb_tpl {
                        Some(tpl) => match tpl.clone() {
                            TupleType(component_types, r) => match component_types
                                .get(usize::from(*i))
                            {
                                None => return Err(TypeErrorParamOutOfRange(pos, *op)),
                                Some(formal) => match mb_val {
                                    None => return Err(TypeErrorEmptyStack(pos, *op)),
                                    Some(actual) => {
                                        if cap_coeffect
                                            .iter()
                                            .all(|c| !capable_read_write(&r, c, &capability_bounds))
                                        {
                                            return Err(CapabilityError(
                                                pos,
                                                *op,
                                                vec![ReadWriteCap(r)],
                                                cap_coeffect,
                                            ));
                                        }
                                        if formal == &actual {
                                            stack_type.push_back(tpl)
                                        } else {
                                            return Err(TypeErrorInit(pos, formal.clone(), actual));
                                        }
                                    }
                                },
                            },
                            _ => return Err(TypeErrorTupleExpected(pos, *op, tpl)),
                        },
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                    verified_ops.push(VerifiedOpcode::InitOp(*i))
                }
                UnverifiedOpcode::MallocOp => {
                    let mb_type = compile_time_stack.pop();
                    let t = match mb_type {
                        Some(TypeCTStackVal(t)) => t,
                        Some(ctval) => return Err(KindError(pos, *op, TypeKind, ctval)),
                        None => return Err(TypeErrorEmptyCTStack(pos, *op)),
                    };
                    let mb_rgn_handle = stack_type.pop_back();
                    match mb_rgn_handle {
                        Some(HandleType(r)) => {
                            if cap_coeffect
                                .iter()
                                .all(|c| !capable_read_write(&r, c, &capability_bounds))
                            {
                                return Err(CapabilityError(
                                    pos,
                                    *op,
                                    vec![ReadWriteCap(r)],
                                    cap_coeffect,
                                ));
                            }
                        }
                        Some(t) => {
                            return Err(TypeErrorRegionHandleExpected(pos, *op, t));
                        }
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                    stack_type.push_back(t);
                    verified_ops.push(VerifiedOpcode::MallocOp(4)) // TODO: use actual size in bytes of t
                }
                UnverifiedOpcode::ProjOp(i) => {
                    let mb_tpl = stack_type.pop_back();
                    match mb_tpl {
                        Some(tpl) => match tpl {
                            TupleType(component_types, r) => {
                                match component_types.get(usize::from(*i)) {
                                    None => return Err(TypeErrorParamOutOfRange(pos, *op)),
                                    Some(t) => {
                                        if cap_coeffect
                                            .iter()
                                            .all(|c| !capable_read_write(&r, c, &capability_bounds))
                                        {
                                            return Err(CapabilityError(
                                                pos,
                                                *op,
                                                vec![ReadWriteCap(r)],
                                                cap_coeffect,
                                            ));
                                        }
                                        stack_type.push_back(t.clone());
                                    }
                                }
                            }
                            _ => return Err(TypeErrorTupleExpected(pos, *op, tpl)),
                        },
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                    verified_ops.push(VerifiedOpcode::ProjOp(*i))
                }
                UnverifiedOpcode::CallOp => {
                    let mb_type = stack_type.pop_back();
                    match mb_type {
                        Some(t) => match t {
                            GuessType(label) => {
                                constraints.insert(
                                    label,
                                    (stack_type.clone(), compile_time_stack.clone()),
                                );
                            }
                            FuncType(quantified, caps_needed, args) => {
                                let mut instantiation = vec![];
                                for _ in 0..quantified.len() {
                                    match compile_time_stack.pop() {
                                        Some(ctval) => instantiation.push(ctval),
                                        None => {
                                            return Err(TypeErrorNotEnoughCompileTimeArgs(
                                                pos,
                                                quantified.len(),
                                                instantiation.len(),
                                            ))
                                        }
                                    }
                                }
                                let caps_present = &cap_coeffect;
                                let arg_ts_needed = &args;
                                let mut arg_ts_present = vec![];
                                for _ in 0..arg_ts_needed.len() {
                                    match stack_type.pop_back() {
                                        Some(t) => arg_ts_present.push(t.clone()),
                                        None => {
                                            return Err(TypeErrorNotEnoughRuntimeArgs(
                                                pos,
                                                arg_ts_needed.len(),
                                                arg_ts_present.len(),
                                            ));
                                        }
                                    }
                                }
                                let (rgn_assignments, cap_assignments, type_assignments) =
                                    get_substitutions(
                                        pos,
                                        instantiation,
                                        quantified,
                                        &capability_bounds,
                                    )?;
                                let caps_needed_subbed =
                                    substitute_c(&caps_needed, &rgn_assignments, &cap_assignments);
                                let caps_are_sufficient = caps_satisfy_caps(
                                    caps_present,
                                    &caps_needed_subbed,
                                    &capability_bounds,
                                );
                                if !caps_are_sufficient {
                                    return Err(CapabilityError(
                                        pos,
                                        *op,
                                        caps_needed_subbed.clone(),
                                        caps_present.clone(),
                                    ));
                                }
                                let types_match = arg_ts_present
                                    .iter()
                                    .zip(arg_ts_needed.iter())
                                    .all(|(t1, t2)| {
                                        type_eq(
                                            t1,
                                            &substitute_t(
                                                t2,
                                                &type_assignments,
                                                &rgn_assignments,
                                                &cap_assignments,
                                            ),
                                        )
                                    });
                                if !types_match {
                                    let arg_ts_needed = arg_ts_needed
                                        .iter()
                                        .map(|t| {
                                            substitute_t(
                                                t,
                                                &type_assignments,
                                                &rgn_assignments,
                                                &cap_assignments,
                                            )
                                        })
                                        .collect::<Vec<_>>();
                                    return Err(TypeErrorCallArgTypesMismatch(
                                        pos,
                                        arg_ts_needed,
                                        arg_ts_present,
                                    ));
                                }
                            }
                            _ => return Err(TypeErrorFunctionExpected(pos, *op, t)),
                        },
                        None => return Err(TypeErrorEmptyStack(pos, *op)),
                    }
                    verified_ops.push(VerifiedOpcode::CallOp)
                }
            },
        }
        pos += 1;
    }
    if exist_stack.len() > 0 {
        return Err(TypeErrorNonEmptyExistStack(*label));
    }
    let t = FuncType(kind_context, cap_coeffect, arg_types);
    Ok((VerifiedStmt::Func(*label, t, verified_ops), constraints))
}

/// Check if a capability is able to read and write in the given region.
fn capable_read_write(
    rgn: &Region,
    cap: &Capability,
    cap_bounds: &HashMap<Id, Vec<Capability>>,
) -> bool {
    match cap {
        UniqueCap(rgn2) | ReadWriteCap(rgn2) if *rgn == *rgn2 => true,
        VarCap(id) => {
            let caps = cap_bounds.get(id).unwrap();
            caps.iter().any(|c| capable_read_write(rgn, c, cap_bounds))
        }
        _ => false,
    }
}

/// Produce, from some function type information and the top of the compile-time stack,
/// some hashmaps describing substitutions that must be made in the rest of the type of the function.
fn get_substitutions(
    pos: Pos,
    ct_args: Vec<CTStackVal>,
    quantified: KindContext,
    cap_bounds: &HashMap<Id, Vec<Capability>>,
) -> Result<
    (
        HashMap<Id, Region>,
        HashMap<Id, Vec<Capability>>,
        HashMap<Id, Type>,
    ),
    Error,
> {
    let mut ct_args = ct_args.iter();
    let mut cap_assignments: HashMap<Id, Vec<Capability>> = HashMap::new();
    let mut rgn_assignments: HashMap<Id, Region> = HashMap::new();
    let mut type_assignments: HashMap<Id, Type> = HashMap::new();
    if ct_args.len() != quantified.len() {
        panic!("instantiate given vectors of unequal length; this should have been handled by the caller")
    }

    for entry in quantified {
        let actual = ct_args.next().unwrap();
        match entry {
            CapabilityKindContextEntry(id, bound) => match actual {
                CapCTStackVal(c) => {
                    // check that the instantiated capability is more restrictive than the formal one, or equally restrictive
                    if caps_satisfy_caps(c, &bound, &cap_bounds) {
                        cap_assignments.insert(id, c.to_vec());
                    } else {
                        return Err(CapabilityErrorBadInstantiation(pos, bound, c.to_vec()));
                    }
                }
                ctval => {
                    return Err(KindErrorBadInstantiation(
                        pos,
                        CapabilityKind,
                        ctval.clone(),
                    ))
                }
            },
            RegionKindContextEntry(id) => match actual {
                RegionCTStackVal(r) => {
                    rgn_assignments.insert(id, *r);
                }
                ctval => return Err(KindErrorBadInstantiation(pos, RegionKind, ctval.clone())),
            },
            TypeKindContextEntry(id) => match actual {
                TypeCTStackVal(t) => {
                    type_assignments.insert(id, t.clone());
                }
                ctval => return Err(KindErrorBadInstantiation(pos, TypeKind, ctval.clone())), // kind error- instantiated type var with a nontype
            },
        }
    }
    // then check that the parameter types match the top of the stack type
    Ok((rgn_assignments, cap_assignments, type_assignments))
}

/// Check if one capability is a subcapability of another.
fn cap_subtype(
    cap1: &Capability,
    cap2: &Capability,
    cap_bounds: &HashMap<Id, Vec<Capability>>,
) -> bool {
    match (cap1, cap2) {
        (UniqueCap(r1), UniqueCap(r2)) if r1 == r2 => true,
        (UniqueCap(r1), ReadWriteCap(r2)) if r1 == r2 => true,
        (ReadWriteCap(r1), ReadWriteCap(r2)) if r1 == r2 => true,
        (ReadWriteCap(_), UniqueCap(_)) => false,
        (VarCap(id1), VarCap(id2)) if id1 == id2 => true,
        (VarCap(id), cap2) => {
            let bound = cap_bounds.get(id).unwrap();
            caps_satisfy_cap(bound, cap2, cap_bounds)
        }
        _ => false,
    }
}

/// Check if a capability set is sufficient to satisfy a given capability.
fn caps_satisfy_cap(
    caps: &[Capability],
    cap: &Capability,
    cap_bounds: &HashMap<Id, Vec<Capability>>,
) -> bool {
    caps.iter().any(|c_p| cap_subtype(c_p, cap, cap_bounds))
}

/// Check if a capability set is sufficient to satisfy another capability set.
fn caps_satisfy_caps(
    caps1: &[Capability],
    caps2: &[Capability],
    cap_bounds: &HashMap<Id, Vec<Capability>>,
) -> bool {
    caps2.iter().all(|c| caps_satisfy_cap(caps1, c, cap_bounds))
}

/// Perform some variable substitutions within a type.
/// This does not modify the original.
fn substitute_t(
    typ: &Type,
    tsubs: &HashMap<Id, Type>,
    rsubs: &HashMap<Id, Region>,
    csubs: &HashMap<Id, Vec<Capability>>,
) -> Type {
    match typ {
        I32Type => I32Type,
        HandleType(r) => HandleType(substitute_r(r, rsubs)),
        MutableType(t) => MutableType(Box::new(substitute_t(t, tsubs, rsubs, csubs))),
        TupleType(ts, r) => TupleType(
            ts.iter()
                .map(|t| substitute_t(t, tsubs, rsubs, csubs))
                .collect(),
            substitute_r(r, rsubs),
        ),
        ArrayType(t) => ArrayType(Box::new(substitute_t(t, tsubs, rsubs, csubs))),
        VarType(id) => match tsubs.get(id) {
            Some(new) => new.clone(),
            None => VarType(*id),
        },
        FuncType(kind_context, caps, args) => FuncType(
            kind_context.clone(),
            substitute_c(caps, rsubs, csubs),
            args.iter()
                .map(|t| substitute_t(t, tsubs, rsubs, csubs))
                .collect(),
        ),
        ExistsType(x, t) => ExistsType(*x, Box::new(substitute_t(t, tsubs, rsubs, csubs))),
        GuessType(label) => GuessType(*label),
    }
}

/// Perform some variable substitutions in a compile-time region value.
/// This does not modify the original
fn substitute_r(rgn: &Region, rsubs: &HashMap<Id, Region>) -> Region {
    match rgn {
        Region::HeapRgn => Region::HeapRgn,
        VarRgn(id) => match rsubs.get(id) {
            Some(new) => new.clone(),
            None => VarRgn(*id),
        },
    }
}

/// Perform some variable substitutions in a capability set.
/// This does not modify the original.
fn substitute_c(
    caps: &Vec<Capability>,
    rsubs: &HashMap<Id, Region>,
    csubs: &HashMap<Id, Vec<Capability>>,
) -> Vec<Capability> {
    let mut out = vec![];
    for cap in caps {
        match cap {
            UniqueCap(r) => out.push(UniqueCap(substitute_r(r, rsubs))),
            ReadWriteCap(r) => out.push(ReadWriteCap(substitute_r(r, rsubs))),
            VarCap(id) => match csubs.get(id) {
                Some(new) => out.extend(new.clone()),
                None => out.push(VarCap(*id)),
            },
        }
    }
    return out;
}

/// Check if two types are equal, for typechecking purposes.
fn type_eq(type1: &Type, type2: &Type) -> bool {
    match (type1, type2) {
        (I32Type, I32Type) => true,
        (HandleType(r1), HandleType(r2)) => r1 == r2,
        (MutableType(t1), MutableType(t2)) => type_eq(t1, t2),
        (TupleType(ts1, r1), TupleType(ts2, r2)) => {
            r1 == r2 && ts1.len() == ts2.len() && {
                let mut ts2 = ts2.iter();
                for t1 in ts1 {
                    let t2 = ts2.next().unwrap();
                    if !type_eq(t1, t2) {
                        return false;
                    }
                }
                return true;
            }
        }
        (ArrayType(t1), ArrayType(t2)) => type_eq(t1, t2),
        (VarType(id1), VarType(id2)) => id1 == id2,
        (FuncType(kind_context1, _caps1, ts1), FuncType(kind_context2, _caps2, ts2)) => {
            if kind_context1.len() != kind_context2.len() {
                return false;
            }
            let mut kind_context2_iter = kind_context2.iter();
            let mut cap_assignments = HashMap::new();
            let mut rgn_assignments = HashMap::new();
            let mut type_assignments = HashMap::new();
            for entry1 in kind_context1 {
                let entry2 = kind_context2_iter.next().unwrap();
                match (entry1, entry2) {
                    (
                        CapabilityKindContextEntry(id1, _bound1),
                        CapabilityKindContextEntry(id2, _bound2),
                    ) => {
                        // TODO: check capability equivalence of bounds
                        cap_assignments.insert(*id2, vec![VarCap(*id1)]);
                    }
                    (RegionKindContextEntry(id1), RegionKindContextEntry(id2)) => {
                        rgn_assignments.insert(*id2, VarRgn(*id1));
                    }
                    (TypeKindContextEntry(id1), TypeKindContextEntry(id2)) => {
                        type_assignments.insert(*id2, VarType(*id1));
                    }
                    _ => return false,
                }
            }
            let types_match = ts1.iter().zip(ts2.iter()).all(|(t1, t2)| {
                type_eq(
                    t1,
                    &substitute_t(t2, &type_assignments, &rgn_assignments, &cap_assignments),
                )
            });
            if !types_match {
                return false;
            }
            // TODO: check capability equivalence
            true
        }
        (ExistsType(id1, t1), ExistsType(id2, t2)) => {
            let mut sub = HashMap::new();
            sub.insert(*id2, VarType(*id1));
            let t2_subbed = substitute_t(t2, &sub, &HashMap::new(), &HashMap::new());
            type_eq(t1, &t2_subbed)
        }
        (GuessType(label1), GuessType(label2)) => label1 == label2,
        (_, _) => false,
    }
}
